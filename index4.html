<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning Reflections From The Course</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles4.css">
</head>
<body>
    <header>
        <h1>Learning Reflections From The Course</h1>
    </header>
    <main>
        <section>
            <h2>The Transaction Costs and Algorithmic Complexity Costs</h2>
            <p>In regards to the algorithms computation effectiveness, a definitive understanding is necessary from a practical perspective:</p>
            <ul>
                <li><strong>Time Complexity:</strong> Enables target greenhouse problems to be solved fast, a requisite in real-time environments.</li>
                <li><strong>Space Complexity:</strong> Minimizes memory allocation, allowing applications to function on low-specification hardware.</li>
                <li><strong>Growth Informatics:</strong> Such as O(1) (constant growth) or O(n log n) (most popular of efficient sorting algorithms) assist in determining how procedures perform as their resources grow.</li>
            </ul>
        </section>
        <section>
            <h2>Final Thoughts on Chapter 2 Principles</h2>
            <p>There are certain considerations that, when violated, undermine the performance of models, cut down interference noise, or improve the accuracy of decision-making:</p>
            <ul>
                <li><strong>Pruning:</strong> Cut off unfruitful branches on search trees in recursive solutions to make them efficient.</li>
                <li><strong>Hashing:</strong> Combines key and value together into an array space that is indexed for easy access, mostly used in dictionaries or caches.</li>
                <li><strong>Union-Find:</strong> Deals with and solves problems concerning isolated or connected parts of a graph.</li>
            </ul>
        </section>
        <section>
            <h2>Finding Solutions to Complex Problems</h2>
            <p>Making the right choice is critical across diverse types of problems:</p>
            <ul>
                <li><strong>Iteration:</strong> Best for operating across all wheels, fiddling and changing, or making certain revolutions such as going through instances of an array.</li>
                <li><strong>Recursion:</strong> Constructs structured like trees with self-similar elements, such as the factorial function or working around and visiting various parts of a tree.</li>
                <li><strong>Backtracking:</strong> A search strategy for problems involving constraints, such as a Sudoku puzzle.</li>
            </ul>
        </section>
        <section>
            <h2>Differences Between Trees and Graphs</h2>
            <ul>
                <li><strong>Trees:</strong> A tree is an acyclic connected graph that represents a level-based dataset such as an organizational structure.</li>
                <li><strong>Graphs:</strong> Used for social networking, where they may allow cycles and disconnected parts.</li>
                <li><strong>Traversal Algorithms:</strong> Depth-first search (DFS) and breadth-first search (BFS) have different objectives.</li>
            </ul>
        </section>
        <section>
            <h2>Graph Algorithms: Spanning Trees and Shortest Paths</h2>
            <ul>
                <li><strong>Prim’s and Kruskal’s:</strong> Join certain nodes at the lowest cost possible, commonly used in networking.</li>
                <li><strong>Dijkstra’s and Bellman-Ford:</strong> Find optimal paths, essential in navigation systems like GPS.</li>
            </ul>
        </section>
        <section>
            <h2>Enhancing Problem Situations Using Tree Structures</h2>
            <ul>
                <li><strong>Binary Search Trees (BSTs):</strong> Useful for search, insertion, and deletion operations.</li>
                <li><strong>AVL Trees:</strong> Guarantee a balanced tree structure with logarithmic height.</li>
                <li><strong>Heaps:</strong> Allow efficient access to the maximum or minimum element, central to priority queues.</li>
                <li><strong>Tries:</strong> Efficient for string dataset storage, often used in auto-complete functionality.</li>
            </ul>
        </section>
        <section>
            <h2>Sorting and Searching Techniques</h2>
            <ul>
                <li><strong>Sorting Algorithms:</strong> Merge Sort and Heap Sort help optimize data arrangement.</li>
                <li><strong>Searching Algorithms:</strong> Binary Search is crucial for searching sorted arrays, such as in online shops.</li>
            </ul>
        </section>
        <section>
            <h2>Diverse Algorithm Design Techniques</h2>
            <ul>
                <li><strong>Divide and Conquer:</strong> Breaks down problems into smaller, manageable tasks (e.g., Merge Sort).</li>
                <li><strong>Dynamic Programming:</strong> Solves problems by utilizing previously solved similar subproblems (e.g., Knapsack Problem).</li>
                <li><strong>Greedy Algorithms:</strong> Solve optimization problems by choosing the best option locally (e.g., Huffman Coding).</li>
            </ul>
        </section>
        <section>
            <h2>Thoughtful Reflections on Algorithmic Approaches</h2>
            <ul>
                <li><strong>Choosing Efficient Approaches:</strong> Evaluate the constraints of the problem and the necessary resources for the algorithm.</li>
                <li><strong>Balancing Design Constraints:</strong> In some cases, balancing trees or hash tables might be necessary for efficient operations.</li>
                <li><strong>Evaluating Solutions:</strong> Ensure robust solutions by focusing on time complexity and edge case handling.</li>
            </ul>
        </section>
    </main>
    <footer>
        <p>&copy; Created by Aditya</p>
    </footer>
</body>
</html>
